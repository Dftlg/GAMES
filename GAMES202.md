# Lecture3

## Shadow Mapping

存在问题：

**自遮挡**

![image-20220410163204864](GAMES202/image-20220410163204864.png)

由于场景投影到光源计算的深度时，其深度图是离散的像素点，对于单个像素存储了显示场景中类似于一条正方体射线的深度，其中一个值直接表示了一个小平面深度。从而产生自模糊。

**解决方式**

通过加上一个bias去调整实际深度

**走样**

![image-20220410165343604](GAMES202/image-20220410165343604.png)

## Second-depth shadow mapping

![image-20220410164314567](GAMES202/image-20220410164314567.png)

存阴影贴图时不仅仅存最小的深度，同时存储第二小深度，并将最小深度和第二小深度平均计算中间深度当作阴影贴图。

存在问题：

1. 模型需要有两个面，不能像地板

2. 需要计算多次深度，虽然时间复杂度还是O(n)，但依旧难以应用到实时

   

![image-20220410170141953](GAMES202/image-20220410170141953.png)

![image-20220410170329561](GAMES202/image-20220410170329561.png)

下面一项是归一化常数

比如f(x)函数为2的常值函数，可以把2提出积分，从而下面的归一化常数为2

![image-20220410193752548](GAMES202/image-20220410193752548.png)

什么时候积分是可以近似的

1. 其积分的区域很小，如点光源或者直接光照
2. 另外后面的积分项是平滑的积分，如面光源

## PCSS(Percentage closer soft shadows)

### Percentage Closer Filtering(PCF)

使用了一种抗锯齿技术，同时可被用于生成软阴影

在PCSS中这种Filter并不是使用在以下两种过程中

1. 并不使用在最后生成场景阶段，并不是完全生成完包含阴影的场景，然后进行模糊
2. 并不使用在生成阴影贴图阶段

### PCSS具体做法

#### 第一步

![image-20220410203959464](GAMES202/image-20220410203959464.png)

生成阴影贴图阶段不变

在进行阴影渲染过程中，原先ShadowMapping，对于任意渲染点获取该渲染点到光源的深度，也就是提取深度图中一个的值，PCSS不再仅仅考虑深度图中的一个像素值（图中蓝点），而是找该点周围一圈的像素，比如找7*7的每一个像素区域，每一个深度都进行比较，然后将这些值进行平均，从而获取到一个在0到1之间的可视值。

![image-20220410204238108](GAMES202/image-20220410204238108.png)

缺点：每个着色点都需要进行多次深度比较

**过滤区域大小的影响**

过小会导致过于尖锐类似于正常的Shadowmapping

过大会导致阴影过于平滑，糊在一起

#### 第二步

观察什么地方生成使用硬阴影，什么时候使用软阴影，软阴影的过滤大小在不同地方应该怎么设置

![image-20220410205100872](GAMES202/image-20220410205100872.png)

可以看出软阴影和硬阴影与遮挡物的距离有关

从而得到

**过滤大小与遮挡物距离有关**

![image-20220410205337548](GAMES202/image-20220410205337548.png)

**从而过滤大小与光源大小以及遮挡物距离有关**

![image-20220410205939985](GAMES202/image-20220410205939985.png)

**从而PCSS的整体步骤为**

1. 首先计算遮挡物（blocker）到渲染点的具体距离
2. 使用平均的的遮挡物深度以及光源大小决定过滤器大小
3. 进行PCF操作

其中第一步具体为：

从渲染点连向点光源，取其中一个区域，判断是否在阴影中，若在阴影中，那么那个像素一定是个遮挡物，然后记录遮挡物深度

那么第一步的遮挡物怎么找到需要取多大的区域？

第一种方法：通常取5*5的区域

第二种方法

![image-20220410210819678](GAMES202/image-20220410210819678.png)

通过渲染点与光源连线

# Lecture4

PCF的数学形式

![image-20220410214658046](GAMES202/image-20220410214658046.png)

下面属于N（p）表示点P周围的点

那么PCSS的符号表示方式

![image-20220410214941565](GAMES202/image-20220410214941565.png)

其中x+那个符号为取0或1函数，如果里面大于0那么最终值为1，如果小于0位最终值为0

所以PCF不是对shadowmap进行模糊操作也不是在模型图像上进行模糊操作

![image-20220410215309537](GAMES202/image-20220410215309537.png)

## VSSM Variance Soft Shadow Mapping

针对PCSS第一步和第三步需要对Texture进行多次采样慢的问题

#### 针对第三步加速解决方案

问题转换：在第三步中需要对一个区域内的采样点比较深度值并计算平均的0-1之间的一个值，那么从另一个角度上看，是为了求比中间采样点深度值低的点（一定区域就是指采样深度值的区域）

怎么获取得知比已知深度值更低的结果

使用直方图或正态分布可以近似估计可以研究该深度值在所有深度值大概排第几。

![image-20220414192143556](GAMES202/image-20220414192143556.png)

正态分布如何获得？需要均值以及期望方差

**VSSM基本思想是**：

​	**使用正态分布区估计该深度值所在区域内的所在位置（或者使用其他分布）**

##### 使用正态分布去估计

###### 步骤一求解正态分布

​	**为求解正态分布需要在一定区域内快速计算深度的均值以及方差。**

如何求解均值方法可以使用

1. ​	**硬件的MipMAPing方法**
2. ​	**Summed Area Tables(SAT)**

如何求解方差可以使用

1. $$
   Var(X)=E(X^2)-E^2(X)
   $$

   E(X)指的就是该区域的深度平均值

   前面一项的计算需要另一张深度图，深度图中每一个值是原深度图的平方倍（可以将另一张深度图生成到另一个图象通道中）成为square-depth map

   

###### 步骤二使用CDF估计所在位置

![image-20220414194226896](GAMES202/image-20220414194226896.png)

在的到CDF图后，那么问在一个区域内深度值比1(中间像素)小的像素应该有多少个

也就是CDF函数小于1的面积，可通过将CDF转换为PDF求解

对于CDF的面积可以直接使用表(误差函数)去获取



##### 另一种方法使用切比雪夫不等式直接估计

使用不等式Chebychev不等式(切比雪夫不等式)

可以的到随机变量，超过某一个值得概率，但又不需要知道这个分布是什么，只需要知道期望和方差

注意：这个t需要在均值得右边才好用

![image-20220414195658869](GAMES202/image-20220414195658869.png)

在VSSM里直接近似估计将小于等于号直接改为约定于

#### VSSM的性能

**内存消耗：**

需要一张额外的平方深度图

**计算性能：**

1. 对深度图进行一次平均O(1)
2. 对平方深度图进行平均计算O(1)
3. 切比雪夫不等式计算O(1) 是否可见

#### 针对第一步加速方案

第一步需要计算遮挡物的平均深度Zocc

![image-20220415182458503](GAMES202/image-20220415182458503.png)

即蓝色部分的平均深度

Key idea:

在一个渲染点的深度是t，在遮挡物区域需要计算比其小的所有像素的平均值记录为
$$
Z_{occ}
$$
不是遮挡物的平均深度记录为
$$
Z_{unocc}
$$
两个平均深度未知，但其一定满足
$$
\frac{N1}{N}Z_{unocc}+\frac{N2}{N}Z_{occ}=Z_{Avg}
$$
两个区域的平均值和等于总区域的平均值，为求解Zocc提出了两个假设：

**假设一：**使用切比雪夫去估计概率：
$$
那么\frac{N1}{N}=P可以使用切比雪夫不等式来大概估计其概率,\frac{N2}{N}=1-P
$$
**假设二：**直接人为Zunocc的深度值为渲染点的深度值。

这样可以直接求解Zocc

## 快速计算均值和方差方法

被应用于VSSM中

### 1.MINMAP

![image-20220415185252332](GAMES202/image-20220415185252332.png)

### 2.Summed Area Tables(SAT)

#### 一维情况：

![image-20220415185727595](GAMES202/image-20220415185727595.png)

给一个范围内求平均=给一个范围求总和

SAT做了预处理操作

##### 预计算过程

先花O(n)时间

将每一格累加

1：1

4:1+3

9:1+3+5

12:1+3+5+3 ...

那么给定任意一段，比如3-7-1这一段

如何知道他们三个的和

**可以使用SAT中1对应的20减去3前一个数5对应的9来的到其加和**

#### 二维情况：

![image-20220415190302047](GAMES202/image-20220415190302047.png)

对于蓝色矩形的平均值

为绿色矩形区域的和值减去两个黄色区域的和值加上左上角重叠区域(小绿色区域的和值)

##### 预计算过程

生成一张图，该图中任意一个像素点(x,y)的值为从(0,0)左上角到(x,y)像素点这个矩形区域所有像素点的和

进行两次一维SAT计算

需要时间O(mn)

## Moment shadow mapping

解决了VSSM问题

![image-20220415191511240](GAMES202/image-20220415191511240.png)

例如第二个图，不能假设维正太分布

遮挡物的分布应该聚集在一个三个峰值的分布，不能用高斯分布区近似

![image-20220415191752077](GAMES202/image-20220415191752077.png)

人们通常能融入过黑的阴影，但过白的阴影无法接受

例如加入只有百分之20的挡不住，但分布认为有百分之50挡不住

![image-20220415192001409](GAMES202/image-20220415192001409.png)

#### Idea

避免VSSM的分布问题

使用更高阶的矩去描述一个分布

![image-20220415192551991](GAMES202/image-20220415192551991.png)

![image-20220415192629272](GAMES202/image-20220415192629272.png)

矩指的是记录一个数的平方，三次方，四次方

Vssm记录了一个一次放和二次方的项。

结论如果保留m阶的矩可一个得到m/2的台阶

![image-20220415192801325](GAMES202/image-20220415192801325.png)

类似于某种展开，可以获取到更好的CDF函数，而不是正态分布

![image-20220415193245998](GAMES202/image-20220415193245998.png)

# Lecture5

## Distance Field Soft Shadows

好处：很快，不存在自遮挡，阴影悬浮

缺点：需要消耗内存，尤其是对于对象和蒙皮角色需要高分辨率内存成本

### Distance Field(functions):

定义了空间中的任意一个点，到物体表面的最小距离。距离场带正负号(有向距离)

![image-20220416162715276](GAMES202/image-20220416162715276.png)

距离函数样例：Blending一个运动边界，存在运动的两张图A和B希望插值出中间的值

每一个像素，从A和B图分别取然后求平均，如上面部分但会生成灰色的，不属于原运动模型的颜色

![image-20220416165212821](GAMES202/image-20220416165212821.png)

为此使用距离场：

定义A图，黑色都是负值，白色都为正值，同时离边界越远其值越大，B图同样

从而使用SDF距离场进行插值

重点：也就是不用考虑模型内部的参数，如颜色，法线什么的，只考虑距离关系，进行插值

### 应用场景：

#### Ray marching

用光线追踪，追踪距离场，看会达到那个表面

简要来说，为光线会与距离场定义的隐含表面求教

##### 其基本思想为：

![image-20220416171132339](GAMES202/image-20220416171132339.png)

例如从右下角初始点，发射定向光线，获取该点的SDF距离场的值，该值表示可能与任意物体的最近距离，那么从光线的定向方向出发移动这个最近距离，表示一定不可能与任意物体产生相交。

从而光线的出发点就可以达到第一个未知，图中(中间的圆点），继续获取该点的距离场值，光源继续移动安全距离，直到移动到的新点距离值足够小(表明与物体相交)，或者光线向前移动了非常远距离(表示什么东西都不相交)。

![image-20220429181056963](GAMES202/image-20220429181056963.png)

SDF除啦可以提供安全距离，还可以提供安全角度()

安全角度含义是，加入存在一个着色点，发出的光线中存在一个点，该点的SDF表示其周围多远存在物体，那么可以得到一个安全角度，在这个角度范围内都不会存在物体。

从而这个安全角度越小，能看到的东西越少，也就是没有遮挡，可见性为1

#### 那么安全角度如何得到？

![image-20220429181524182](GAMES202/image-20220429181524182.png)

##### 方案一：(较麻烦)

通过raymarching找到路径上的点，求每个点的安全角度，其中最小的安全角度就是这个着色点的安全角度

使用arcsin(SDF的值/走过的距离)

##### 方案二：

直接求SDF的值与走过距离的比值(减少arcsin函数计算)

K的作用：用来决定比值的范围，如果范围过大之间用1处理，比如k取5，那么比值小于0.2时，才有用，不然就直接按1处理。

可以用来控制软硬阴影程度

![image-20220429182452054](GAMES202/image-20220429182452054.png)

![image-20220429182722210](GAMES202/image-20220429182722210.png)

Distance Field Soft Shadows优略势

![image-20220429184231014](GAMES202/image-20220429184231014.png)

## Shading from environment light

![image-20220429185212759](GAMES202/image-20220429185212759.png)

环境光认为光照来源于无限远

使用方法为IBL

![image-20220429185737009](GAMES202/image-20220429185737009.png)

使用所有方向取渲染一个点，其中渲染方程不再需要考虑可见性

但计算蒙特卡洛时需要sampling消耗大量时间

![image-20220429192652161](GAMES202/image-20220429192652161.png)